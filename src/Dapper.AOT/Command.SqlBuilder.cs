#if NET6_0_OR_GREATER

using Dapper.Internal;
using System;
using System.Buffers;
using System.Buffers.Text;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.SqlTypes;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace Dapper;

public static partial class DapperAotExtensions
{
    /// <summary>
    /// Create a command from an interpolated string.
    /// </summary>
    public static Command Command(this DbConnection connection, ref Command.SqlBuilder sql, int timeout = 0)
    {
        var cmdText = sql.GetSql();
        var cmd = new Command(connection, null, cmdText, sql.HasParameters ? CommandType.Text : GetCommandType(cmdText), timeout, sql.Parameters);
        sql.Clear();
        return cmd;
    }

    /// <summary>
    /// Create a command from an interpolated string.
    /// </summary>
    public static Command Command(this DbTransaction transaction, ref Command.SqlBuilder sql, int timeout = 0)
    {
        var cmdText = sql.GetSql();
        var cmd = new Command(null, transaction, cmdText, sql.HasParameters ? CommandType.Text : GetCommandType(cmdText), timeout, sql.Parameters);
        sql.Clear();
        return cmd;
    }
}

public readonly partial struct Command
{
    /// <summary>
    /// Interpolated string handler intended for composing SQL.
    /// </summary>
    [InterpolatedStringHandler]
    public ref partial struct SqlBuilder(int literalLength, int formattedCount)
    {
        private Parameter[] _parameters = ArrayPool<Parameter>.Shared.Rent(formattedCount);
        private DefaultInterpolatedStringHandler _handler = new(literalLength, formattedCount, CultureInfo.InvariantCulture);
        private int _paramCount = 0;
        private bool _hasInjectedValue = false;

        internal bool HasParameters => _paramCount != 0;

        internal bool HasInjectedValue => _hasInjectedValue; // this *could* be a pre-validated table name, or it could be SQLi

        /// <summary>
        /// Gets the parameters associated with this operation
        /// </summary>
        public ReadOnlySpan<Parameter> Parameters => new(_parameters, 0, _paramCount);

        // avoid allocating composed names repeatedly
        private static readonly ConcurrentDictionary<(char token, string expression), string> _expressionCache = [];
        private static readonly ConcurrentDictionary<(char token, int index), string> _indexCache = [];

        /// <inheritdoc cref="DefaultInterpolatedStringHandler.AppendLiteral(string)"/>
        public void AppendLiteral(string value) => _handler.AppendLiteral(value);

        string ProposeAndAppendName(char token, string expression, out bool exists, out bool isAutoGenerated)
        {
            // for simple names, use the expression to name the parameter, so @{name} becomes @name
            // otherwise, invent, so @{id + 2} becomes @p0; we can re-use that later *as long as*
            // every use is an expression, and not just somebody passing "p1" as a variable name
            // conflicting with a "p1" that we auto-generated earlier.
            if (CompiledRegex.ParameterName.IsMatch(expression))
            {
                if (!TryFindParam(expression, out var parameter))
                {
                    // all good, no conflict
                    _handler.AppendLiteral(expression);
                    var key = (token, expression);
                    if (!_expressionCache.TryGetValue(key, out var composed))
                    {
                        _expressionCache[key] = composed = $"{key.token}{key.expression}";
                    }
                    isAutoGenerated = exists = false;
                    return composed;
                }
                else if (!parameter.IsAutoGenerated)
                {
                    // found in the query already, but: from the caller;
                    // we can just reuse it
                    _handler.AppendLiteral(expression);
                    isAutoGenerated = false;
                    exists = true;
                    return parameter.Name;
                }
            }

            // either not a valid parameter name, or there's a conflict;
            // try to invent a name; we'll start at where-ever the current param count is
            exists = false;
            isAutoGenerated = true;
            var autoIndex = _paramCount;
            
            while (true)
            {
                DefaultInterpolatedStringHandler sneaky = $"{token}p{autoIndex}"; // uses more span magic

                if (!TryFindParam(GetText(ref sneaky), out _))
                {
                    // no collision, usable; note that the token is already in the buffer
                    _handler.AppendLiteral("p");
                    _handler.AppendFormatted(autoIndex);

                    // and we'll need a string from that
                    var key = (token, index: autoIndex);
                    if (_indexCache.TryGetValue(key, out var composed))
                    {
                        Clear(ref sneaky);
                    }
                    else
                    {
                        _indexCache[key] = composed = sneaky.ToStringAndClear();
                    }
                    return composed;
                }
                Clear(ref sneaky);
                autoIndex = checked(autoIndex + 1); // try again with a different number
            }
        }

        private static partial ReadOnlySpan<char> GetText(ref DefaultInterpolatedStringHandler handler);
        private static partial void Clear(ref DefaultInterpolatedStringHandler handler);

#if NET8_0_OR_GREATER
        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = "get_Text")]
        private static extern partial ReadOnlySpan<char> GetText(ref DefaultInterpolatedStringHandler handler);

        [UnsafeAccessor(UnsafeAccessorKind.Method)]
        private static extern partial void Clear(ref DefaultInterpolatedStringHandler handler);
#else
        // old-school "UnsafeAccessor"
        private static partial void Clear(ref DefaultInterpolatedStringHandler handler)
            => s_clear(ref handler);

        private static partial ReadOnlySpan<char> GetText(ref DefaultInterpolatedStringHandler handler)
            => s_getText(ref handler);

        private delegate ReadOnlySpan<char> GetTextSignature(ref DefaultInterpolatedStringHandler handler);
        private static readonly GetTextSignature s_getText = (GetTextSignature)typeof(DefaultInterpolatedStringHandler).GetMethod("get_Text", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)!.CreateDelegate(typeof(GetTextSignature));

        private delegate void ClearSignature(ref DefaultInterpolatedStringHandler handler);
        private static readonly ClearSignature s_clear = (ClearSignature)typeof(DefaultInterpolatedStringHandler).GetMethod("Clear", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)!.CreateDelegate(typeof(ClearSignature));
#endif

        private bool IsParameter(out char prefix)
        {
            var sql = GetText(ref _handler);
            if (!sql.IsEmpty)
            {
                prefix = sql[sql.Length - 1];
                return prefix is '@' or ':' or '$';
            }
            prefix = default;
            return false;
        }

        /// <summary>
        /// Gets the SQL represented by this instance.
        /// </summary>
        public string GetSql()
        {
            var span = GetText(ref _handler);
            if (span.IsEmpty)
            {
                return "";
            }

#if NET9_0_OR_GREATER
        // if there are no per-usage non-parameter values: use a cache of known SQL, using the alt-lookup
        if (!_hasInjectedValue && s_UseNonFormattedCache)
        {
            if (s_nonFormattedAltCache.TryGetValue(span, out var found))
            {
                // re-usable common SQL
                return found;
            }
            else
            {
                // materialize and store it for next time
                var sql = span.ToString();
                return s_nonFormattedCache[sql] = sql;
            }
        }
#endif
            return span.ToString();
        }

#if NET9_0_OR_GREATER
    // .NET 9 has a span-based lookup that makes it practical to write a SQL cache to avoid allocating per-usage strings
    // as long as it looks like a constant-ish string (i.e. no non-parameter formatted values injected into the payload,
    // which would case cache saturation - we don't want a query with every ID in your database!)
    private static readonly ConcurrentDictionary<string, string> s_nonFormattedCache = [];
    private static readonly ConcurrentDictionary<string, string>.AlternateLookup<ReadOnlySpan<char>> s_nonFormattedAltCache;
    private static readonly bool s_UseNonFormattedCache = s_nonFormattedCache.TryGetAlternateLookup(out s_nonFormattedAltCache);
#endif


        private static class TypeCache<T>
        {
            public static readonly TypeCode RawType = Type.GetTypeCode(typeof(T)); // the raw blittable type, not allowing for Nullable<T> etc
            public static readonly bool IsEnum = (Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T)).IsEnum;

            // the more forgiving type-code, allowing for nullable etc
            public static readonly TypeCode TypeCode = IsEnum
                ? Type.GetTypeCode(Enum.GetUnderlyingType(Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T)))
                : Type.GetTypeCode(Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T));

            public static readonly DbType DbType = TypeCode switch
            {
                TypeCode.Byte => DbType.Byte,
                TypeCode.SByte => DbType.SByte,
                TypeCode.Int16 => DbType.Int16,
                TypeCode.UInt16 => DbType.UInt16,
                TypeCode.Int32 => DbType.Int32,
                TypeCode.UInt32 => DbType.UInt32,
                TypeCode.Int64 => DbType.Int64,
                TypeCode.UInt64 => DbType.UInt64,
                TypeCode.String => DbType.String,
                TypeCode.Boolean => DbType.Boolean,
                _ => Parameter.UnknownType, // leave most other things to the DB
            };
        }

        /// <summary>
        /// If the preceding character indicates that this is a parameter: adds a parameter to the command;
        /// otherwise, appends the formatted value to the SQL.
        /// </summary>
        public void AppendFormatted<T>(T value, int alignment = 0, string format = "", [CallerArgumentExpression(nameof(value))] string expression = "")
        {
            // note: our use of [CallerArgumentExpression] here means that if we added lots of AppendFormatted overloads, it would be somewhat ambiguous;
            // so to avoid problems, we run everything through one path. This works pretty well, especially on modern JITs.
            if (IsParameter(out var prefix))
            {
                var dbType = GetDbType(format, TypeCache<T>.DbType);
                if (typeof(T).IsValueType && TypeCache<T>.IsEnum) // additional work to pre-process enum values to integers or strings
                {
                    object? boxed = dbType switch
                    {
                        DbType.String or DbType.AnsiString or DbType.StringFixedLength or DbType.AnsiStringFixedLength => value?.ToString(),
                        DbType.Byte when TypeCache<T>.RawType == TypeCode.Byte => Unsafe.As<T, byte>(ref value),
                        DbType.SByte when TypeCache<T>.RawType == TypeCode.SByte => Unsafe.As<T, sbyte>(ref value),
                        DbType.Int16 when TypeCache<T>.RawType == TypeCode.Int16 => Unsafe.As<T, short>(ref value),
                        DbType.UInt16 when TypeCache<T>.RawType == TypeCode.UInt16 => Unsafe.As<T, ushort>(ref value),
                        DbType.Int32 when TypeCache<T>.RawType == TypeCode.Int32 => CommandFactory.AsValue(Unsafe.As<T, int>(ref value)),
                        DbType.UInt32 when TypeCache<T>.RawType == TypeCode.UInt32 => Unsafe.As<T, uint>(ref value),
                        DbType.Int64 when TypeCache<T>.RawType == TypeCode.Int64 => Unsafe.As<T, long>(ref value),
                        DbType.UInt64 when TypeCache<T>.RawType == TypeCode.UInt64 => Unsafe.As<T, ulong>(ref value),
                        // we *could* write the 8x7 matrix here (ignoring diagonal), but: this should be fine
                        DbType.Byte => Convert.ToByte(value),
                        DbType.SByte => Convert.ToSByte(value),
                        DbType.Int16 => Convert.ToInt16(value),
                        DbType.UInt16 => Convert.ToUInt16(value),
                        DbType.Int32 => CommandFactory.AsValue(Convert.ToInt32(value)),
                        DbType.UInt32 => Convert.ToUInt32(value),
                        DbType.Int64 => Convert.ToInt64(value),
                        DbType.UInt64 => Convert.ToUInt64(value),
                        _ => value,
                    };
                    AppendParameter(boxed, dbType, alignment, expression, prefix);
                }
                else
                {
                    AppendParameter(CommandFactory.AsGenericValue<T>(value), dbType, alignment, expression, prefix);
                }
            }
            else if (typeof(T) == typeof(bool) && alignment == 0 && string.IsNullOrEmpty(format))
            {
                // append literal 1/0; don't count as injection-breaking
                _handler.AppendLiteral(Unsafe.As<T, bool>(ref value) ? "1" : "0");
            }
            else
            {
                _hasInjectedValue = true;
                _handler.AppendFormatted(value, alignment, format);
            }
        }


        static DbType GetDbType(string format, DbType suggested = Parameter.UnknownType)
        {
            if (!string.IsNullOrEmpty(format) && Enum.TryParse<DbType>(format, true, out var preferred))
            {
                return preferred;
            }
            return suggested;
        }

        private void AppendParameter(object? value, DbType type, int size, string expression, char prefix)
        {
            var fullName = ProposeAndAppendName(prefix, expression, out bool exists, out bool isAutoGenerated);
            if (!exists)
            {
                if (_parameters is null or { Length: 0 })
                {
                    _parameters = ArrayPool<Parameter>.Shared.Rent(4);
                }
                else if (_parameters.Length == _paramCount)
                {
                    var bigger = ArrayPool<Parameter>.Shared.Rent(2 * _parameters.Length);
                    Parameters.CopyTo(bigger);
                    ArrayPool<Parameter>.Shared.Return(_parameters);
                    _parameters = bigger;
                }
                _parameters[_paramCount++] = new(fullName, value ?? DBNull.Value, type, size, isAutoGenerated);
            }
        }

        private bool TryFindParam(scoped ReadOnlySpan<char> name, out Parameter parameter)
        {
            foreach (var param in this.Parameters)
            {
                if (name.Equals(param.Name, StringComparison.InvariantCultureIgnoreCase))
                {
                    parameter = param;
                    return true;
                }
            }
            parameter = default;
            return false;
        }

        /// <summary>
        /// Reset any data associated with this instance.
        /// </summary>
        public void Clear()
        {
            Clear(ref _handler);
            if (_parameters is not null)
            {
                ArrayPool<Parameter>.Shared.Return(_parameters);
            }
            this = default;
        }
    }
}

#endif